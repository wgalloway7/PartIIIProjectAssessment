#montecarlo.jl
include("lattice.jl")
using Statistics
using LsqFit
using Base.Threads

@inline function monte_carlo_timestep!(lattice::Lattice, move::String, beta::Float64; verbose::Bool=false, l::Int64=1)
    # generates potential move's flip sites
    flips = generate_moves(lattice, move, l)

    # calculates energy difference of proposed move
    energy_difference = energy_change(lattice,flips)
    #println("flip = $flips")
    #println(lattice.grid[flips[1],flips[2]])
    #println("energy = $energy_difference")
    #println(exp(-beta * energy_difference))

    # MH logic on whether to accept the proposed move
    if energy_difference <= 0 || rand() < exp(-beta * energy_difference)
        # if move is accepted, flip the propose sites
        do_flips(lattice, flips)
        return 1
    else
        return 0
    end

end

function run_metropolis_algorithm(lattice::Lattice, beta::Float64, l::Int64, move::String = "single flip"; maximum_iterations::Int64=10000, verbose::Bool=false)
    # runs metropolis-hastings algorithm
    # for given move funciton, beta and l
    # predetermined iteration cutoff
    # cutoff is generated by studying autocorrelation function

    current_iteration = 0
    accepted_candidates = 0

    #iterate algorithm until cutoff
    while (current_iteration <= maximum_iterations)
 
        accepted_candidates_increase = monte_carlo_timestep!(lattice, move, beta; verbose=verbose, l=l)

        current_iteration += 1
        accepted_candidates += accepted_candidates_increase
        # calculate correlation function every lattice.L^2 iterations
        # ie 1 Monte-Carlo iteration
        #if use_correlation   
    end
    return (current_iteration, accepted_candidates)
end

function generate_T_intervals(T_hot::Float64, T_cold::Float64, num_intervals::Int64)
    # generates a non-linearly spaced array of temperatures
    # we want a higher density of temperature at T_cold than T_hot
    # as we are interested in the low temperature regime
    if T_hot <= T_cold
        throw(ArgumentError("T_hot must be greater than T_cold"))
    elseif T_cold == 0.0
        throw(ArgumentError("T_cold must be greater than 0"))
    end
    return T_hot .* (T_cold / T_hot) .^ (range(0, 1, length=num_intervals))
end

function generate_all_autocorrelations(lattice::Lattice, beta_values::Vector{Float64}; l::Int64 = 1, move::String = "single flip", max_lag::Int64 = 250, measurement_steps::Int64 = 15000, equilib_steps::Int64 = 1250)
    # generate energy, magnetisation and spin autocorrelation functions
    MC_step = lattice.L^2
    lag = [i for i in 0:max_lag]
    E_autocorr_beta = []
    M_autocorr_beta = []
    s_autocorr_beta = []
    unconnected_autocorr_beta = []
    
    m_values = []
    E_values = []
    lattice.grid = random_configuration(lattice.L, 0.0)
    for beta in beta_values
        println("beta = $beta")
        E_history = []
        m_history = []
        
        s_history = Vector{Matrix{Int64}}()

        for _ in 1:equilib_steps * MC_step
            monte_carlo_timestep!(lattice, move, beta, l = l)
        end
        
        for _ in 1:measurement_steps
            E = energy(lattice)
            m = sum(lattice.grid) / lattice.L^2

            push!(E_history, E)
            push!(m_history, m)
            push!(s_history, copy(lattice.grid))

            for _ in 1:MC_step
                monte_carlo_timestep!(lattice, move, beta, l = l)
            end
        end

        m_avg = mean(m_history)
        m_var = var(m_history)
        E_avg = mean(E_history)
        E_var = var(E_history)

        n_history = length(s_history)
        lattice_avg = zeros(size(s_history[1])...)
        for mat in s_history
            lattice_avg .+= mat
        end
        lattice_avg ./= n_history

        m_ac_history = []
        E_ac_history = []
        s_ac_history = []
        for tau in lag
            m_autocorr = 0
            E_autocorr = 0
            s_autocorr_matrix = zeros(lattice.L, lattice.L)

            for t0 in 1:(length(m_history) - tau)
                m_autocorr += (m_history[t0] - m_avg) * (m_history[t0 + tau] - m_avg)
                E_autocorr += (E_history[t0] - E_avg) * (E_history[t0 + tau] - E_avg)
                s_autocorr_matrix += (s_history[t0] .- lattice_avg) .* (s_history[t0 + tau] .- lattice_avg)
            end

            m_autocorr /= ((length(m_history) - tau) * m_var)
            E_autocorr /= ((length(E_history) - tau) * E_var)
            s_autocorr_matrix ./= (length(s_history) - tau)
            push!(m_ac_history, m_autocorr)
            push!(E_ac_history, E_autocorr)
            push!(s_ac_history, s_autocorr_matrix)
        end
        s_ac_history = [s_ac_history[t] ./ s_ac_history[1] for t in eachindex(s_ac_history)]
        s_autocorr = [mean(mat) for mat in s_ac_history]


        push!(E_autocorr_beta, E_ac_history)
        push!(M_autocorr_beta, m_ac_history)
        push!(s_autocorr_beta, s_autocorr)

        E_history = nothing
        m_history = nothing
        s_history = nothing
        GC.gc()  # (optional) force garbage collection
    end
    return beta_values, E_autocorr_beta, M_autocorr_beta, s_autocorr_beta
end


function generate_all_tau(lattice::Lattice, beta_values::Vector{Float64}, save_file::Bool = false; l::Int64 = 1, move::String = "single flip", filename::String = "autocorrelation.csv", max_lag::Int64 = 250, measurement_steps::Int64 = 15000, equilib_steps::Int64 = 1250)
    _, E_autocorr_beta, M_autocorr_beta, s_autocorr_beta = generate_all_autocorrelations(lattice, beta_values, l = l, move = move, max_lag = max_lag, measurement_steps = measurement_steps, equilib_steps = equilib_steps)

    if save_file
        open("E_$(filename)", "w") do io
            for entry in E_autocorr_beta
                autocorr = entry  # Extract the autocorrelation vector
                writedlm(io, [autocorr], ',')  # Write as a row
            end
        end
        open("M_$(filename)", "w") do io
            for entry in M_autocorr_beta
                autocorr = entry
                writedlm(io, [autocorr], ',')  # Write as a row
            end
        end
        open("S_$(filename)", "w") do io
            for entry in s_autocorr_beta
                autocorr = entry  # Extract the autocorrelation vector
                writedlm(io, [autocorr], ',')  # Write as a row
            end
        end
    end

    E_tau = []
    m_tau = []
    s_tau = []

    for (i,beta) in enumerate(beta_values)
        tau_E = length(E_autocorr_beta[i])
        E_autocorr = E_autocorr_beta[i]
        for (j,a) in enumerate(E_autocorr)
            if a < exp(-1)
                tau_E = j
                break
            end
        end
        push!(E_tau, tau_E)

        tau_m = length(M_autocorr_beta[i])
        m_autocorr = M_autocorr_beta[i]
        for (j,a) in enumerate(m_autocorr)
            if a < exp(-1)
                tau_m = j
                break
            end
        end
        push!(m_tau, tau_m)

        tau_s = length(s_autocorr_beta[i])
        s_autocorr = s_autocorr_beta[i]
        for (j,a) in enumerate(s_autocorr)
            if a < exp(-1)
                tau_s = j
                break
            end
        end
        push!(s_tau, tau_s)
    end
    return E_tau, m_tau, s_tau
end


function generate_E_m_autocorrelations(lattice::Lattice, beta_values::Vector{Float64}; l::Int64 = 1, move::String = "single flip", max_lag::Int64 = 250, measurement_steps::Int64 = 15000, equilib_steps::Int64 = 1250, normalise::Bool = true, show_configs::Bool = false)
    # generate energy, magnetisation and unconnected correlation functions
    # old function, should be annealing using single flips
    MC_step = lattice.L^2
    lag = [i for i in 0:max_lag]
    E_autocorr_beta = []
    M_autocorr_beta = []
    unconnected_autocorr_beta = []

    
    m_values = []
    E_values = []
    println("max_lag = $max_lag")
    println("measurement_steps = $measurement_steps")
    println("equilib_steps = $equilib_steps")

    lattice.grid = random_configuration(lattice.L, 0.0)
    

    for beta in beta_values
        println("beta = $beta")
        E_history = []
        m_history = []
        #random initial configuration to equilibrate from
        

        for j in 1:equilib_steps * MC_step
            monte_carlo_timestep!(lattice, move, beta, l = l)
        end
        
        initial_config = copy(lattice.grid)
        unconnected_autocorr = []
        for j in 1:measurement_steps
            E = energy(lattice)
            m = sum(lattice.grid) / lattice.L^2

            push!(E_history, E)
            push!(m_history, m)

            push!(unconnected_autocorr, (sum(lattice.grid .== initial_config) / lattice.L^2))
            
            for _ in 1:MC_step
                monte_carlo_timestep!(lattice, move, beta, l = l)
            end
            if beta > 0.6 && show_configs
                if abs(sum(lattice.grid)) != lattice.L^2
                    p = plot()
                    heatmap!(p, lattice.grid)
                    savefig(p, "$(beta)_$(j).png")
                end
                
            end
        end

        m_avg = mean(m_history)
        m_var = var(m_history)
        E_avg = mean(E_history)
        E_var = var(E_history)


        m_ac_history = []
        E_ac_history = []
        for tau in lag
            m_autocorr = 0
            E_autocorr = 0

            for t0 in 1:(length(m_history) - tau)
                m_autocorr += (m_history[t0] - m_avg) * (m_history[t0 + tau] - m_avg)
                E_autocorr += (E_history[t0] - E_avg) * (E_history[t0 + tau] - E_avg)
            end
            if normalise
                m_autocorr /= ((length(m_history) - tau) * m_var)
                E_autocorr /= ((length(E_history) - tau) * E_var)
            else
                m_autocorr /= (length(m_history) - tau)
                E_autocorr /= (length(E_history) - tau)
            end
            push!(m_ac_history, m_autocorr)
            push!(E_ac_history, E_autocorr)
        end


        push!(E_autocorr_beta, E_ac_history)
        push!(M_autocorr_beta, m_ac_history)
        push!(unconnected_autocorr_beta, unconnected_autocorr)

        E_history = nothing
        m_history = nothing
        GC.gc()  # (optional) force garbage collection
    end
    return beta_values, E_autocorr_beta, M_autocorr_beta, unconnected_autocorr_beta
end


function generate_E_m_tau(lattice::Lattice, beta_values::Vector{Float64}, save_file::Bool = false; l::Int64 = 1, move::String = "single flip", filename::String = "autocorrelation.csv", max_lag::Int64 = 250, measurement_steps::Int64 = 15000, equilib_steps::Int64 = 1250, normalise::Bool = true)
    _, E_autocorr_beta, M_autocorr_beta, unconnected_autocorr_beta = generate_E_m_autocorrelations(lattice, beta_values, l = l, move = move, max_lag = max_lag, measurement_steps = measurement_steps, equilib_steps = equilib_steps, normalise = normalise)

    if save_file
        open("E_$(filename)", "w") do io
            for entry in E_autocorr_beta
                autocorr = entry  # Extract the autocorrelation vector
                writedlm(io, [autocorr], ',')  # Write as a row
            end
        end
        open("M_$(filename)", "w") do io
            for entry in M_autocorr_beta
                autocorr = entry
                writedlm(io, [autocorr], ',')  # Write as a row
            end
        end

        open("unconnected_$(filename)", "w") do io
            for entry in unconnected_autocorr_beta
                autocorr = entry  # Extract the autocorrelation vector
                writedlm(io, [autocorr], ',')  # Write as a row
            end
        end
    end

    E_tau = []
    m_tau = []

    for (i,beta) in enumerate(beta_values)
        tau_E = NaN
        E_autocorr = E_autocorr_beta[i]
        for (j,a) in enumerate(E_autocorr)
            if a < exp(-1)
                tau_E = j
                break
            end
        end
        push!(E_tau, tau_E)

        tau_m = NaN
        m_autocorr = M_autocorr_beta[i]
        for (j,a) in enumerate(m_autocorr)
            if a < exp(-1)
                tau_m = j
                break
            end
        end
        push!(m_tau, tau_m)
    end
    return E_tau, m_tau
end

function generate_E_m_autocorrelations_with_sf(lattice::Lattice, beta_values::Vector{Float64}; l::Int64 = 1, move::String = "single flip", max_lag::Int64 = 250, measurement_steps::Int64 = 15000, equilib_steps::Int64 = 1250, normalise::Bool = true, show_configs::Bool = false)
    # generate energy, magnetisation and unconnected correlation functions
    MC_step = lattice.L^2
    lag = [i for i in 0:max_lag]
    E_autocorr_beta = []
    M_autocorr_beta = []
    unconnected_autocorr_beta = []

    
    m_values = []
    E_values = []
    println("max_lag = $max_lag")
    println("measurement_steps = $measurement_steps")

    lattice.grid = random_configuration(lattice.L, 0.0)
    

    for beta in beta_values
        println("beta = $beta")
        E_history = []
        m_history = []
        #random initial configuration to equilibrate from
        
        if 0.4 < beta < 0.5
            equilib_steps = 500
        else 
            equilib_steps = 50
        end
        if show_configs
            println("equilibrating")
        end
        println("equilib_steps = $equilib_steps")
        for j in 1:equilib_steps * MC_step
            monte_carlo_timestep!(lattice, "single flip", beta, l = l)
        end
        
        initial_config = copy(lattice.grid)
        unconnected_autocorr = []
        if show_configs
            println("measuring")
        end 
        for j in 1:measurement_steps
            E = energy(lattice)
            m = sum(lattice.grid) / lattice.L^2

            push!(E_history, E)
            push!(m_history, m)

            push!(unconnected_autocorr, (sum(lattice.grid .* initial_config) / lattice.L^2))
            
            for _ in 1:MC_step
                monte_carlo_timestep!(lattice, move, beta, l = l)
            end
            #if beta > 0.6 && show_configs
            #    if abs(sum(lattice.grid)) != lattice.L^2
            #        p = plot()
            #        heatmap!(p, lattice.grid)
            #        savefig(p, "$(beta)_$(j).png")
            #    end
            #    
            #end
        end

        m_avg = mean(m_history)
        m_var = var(m_history)
        E_avg = mean(E_history)
        E_var = var(E_history)


        m_ac_history = []
        E_ac_history = []
        for tau in lag
            m_autocorr = 0
            E_autocorr = 0

            for t0 in 1:(length(m_history) - tau)
                m_autocorr += (m_history[t0] - m_avg) * (m_history[t0 + tau] - m_avg)
                E_autocorr += (E_history[t0] - E_avg) * (E_history[t0 + tau] - E_avg)
            end
            if normalise
                m_autocorr /= ((length(m_history) - tau) * m_var)
                E_autocorr /= ((length(E_history) - tau) * E_var)
            else
                m_autocorr /= (length(m_history) - tau)
                E_autocorr /= (length(E_history) - tau)
            end
            push!(m_ac_history, m_autocorr)
            push!(E_ac_history, E_autocorr)
        end


        push!(E_autocorr_beta, E_ac_history)
        push!(M_autocorr_beta, m_ac_history)
        push!(unconnected_autocorr_beta, unconnected_autocorr)

        E_history = nothing
        m_history = nothing
        GC.gc()  # (optional) force garbage collection
    end
    return beta_values, E_autocorr_beta, M_autocorr_beta, unconnected_autocorr_beta
end


function generate_E_m_tau_with_sf(lattice::Lattice, beta_values::Vector{Float64}, save_file::Bool = false; l::Int64 = 1, move::String = "single flip", filename::String = "autocorrelation.csv", max_lag::Int64 = 250, measurement_steps::Int64 = 15000, equilib_steps::Int64 = 1250, normalise::Bool = true)
    _, E_autocorr_beta, M_autocorr_beta, unconnected_autocorr_beta = generate_E_m_autocorrelations_with_sf(lattice, beta_values, l = l, move = move, max_lag = max_lag, measurement_steps = measurement_steps, equilib_steps = equilib_steps, normalise = normalise)

    if save_file
        open("E_$(filename)", "w") do io
            for entry in E_autocorr_beta
                autocorr = entry  # Extract the autocorrelation vector
                writedlm(io, [autocorr], ',')  # Write as a row
            end
        end
        open("M_$(filename)", "w") do io
            for entry in M_autocorr_beta
                autocorr = entry
                writedlm(io, [autocorr], ',')  # Write as a row
            end
        end

        open("unconnected_$(filename)", "w") do io
            for entry in unconnected_autocorr_beta
                autocorr = entry  # Extract the autocorrelation vector
                writedlm(io, [autocorr], ',')  # Write as a row
            end
        end
    end

    E_tau = []
    m_tau = []

    for (i,beta) in enumerate(beta_values)
        tau_E = NaN
        E_autocorr = E_autocorr_beta[i]
        for (j,a) in enumerate(E_autocorr)
            if a < exp(-1)
                tau_E = j
                break
            end
        end
        push!(E_tau, tau_E)

        tau_m = NaN
        m_autocorr = M_autocorr_beta[i]
        for (j,a) in enumerate(m_autocorr)
            if a < exp(-1)
                tau_m = j
                break
            end
        end
        push!(m_tau, tau_m)
    end
    return E_tau, m_tau
end
#KEEP
function generate_autocorrelation(lattice::Lattice, beta_values::Vector{Float64}; l::Int64 = 1, move::String = "single flip", max_lag::Int64 = 250, measurement_steps::Int64 = 15000, equilib_steps::Int64 = 1250)
    # sum over sites on lattice only at the end
    MC_step = lattice.L^2
    lag = [i for i in 0:max_lag]
    autocorr_beta = []
    m_values = []
    E_values = []

    for beta in beta_values
        println("beta = $beta")
        time = now()
        history = []

        for _ in 1:equilib_steps * MC_step
            monte_carlo_timestep!(lattice, move, beta, l = l)
        end

        #measure lattice evolution every MC step
        for _ in 1:measurement_steps
            measurement = energy(lattice)
            #measurement = sum(lattice.grid) / lattice.L^2
            push!(history, measurement)
            for _ in 1:MC_step
                monte_carlo_timestep!(lattice, move, beta, l = l)
            end
        end

        mag_avg = mean(history)
        mag_var= var(history)

        autocorr_history = []
        for tau in lag
            autocorr = 0
            for t0 in 1:(length(history) - tau)
                autocorr += (history[t0] - mag_avg) * (history[t0 + tau] - mag_avg)
            end
            autocorr = autocorr / ((length(history) - tau)*mag_var)
            push!(autocorr_history, autocorr)
        end
        push!(autocorr_beta, (beta, autocorr_history))
        println(now() - time)
    end
    return autocorr_beta
end
#KEEP
function generate_tau(lattice::Lattice, beta_values::Vector{Float64}, save_file::Bool = false; l::Int64 = 1, move::String = "single flip", filename::String = "autocorrelation.csv", max_lag::Int64 = 250, measurement_steps::Int64 = 15000, equilib_steps::Int64 = 1250)
    autocorr_beta = generate_autocorrelation(lattice, beta_values, l = l, move = move, max_lag = max_lag, measurement_steps = measurement_steps, equilib_steps = equilib_steps)
    if save_file
        open(filename, "w") do io
            for entry in autocorr_beta
                autocorr = entry[2]  # Extract the autocorrelation vector
                writedlm(io, [autocorr], ',')  # Write as a row
            end
        end
    end

    tau_values = []
    for (i, beta) in enumerate(beta_values)
        autocorr = autocorr_beta[i][2]
        tau = length(autocorr)
        for (j,a) in enumerate(autocorr)
            if a < exp(-1)
                tau = j
                break
            end
        end
        push!(tau_values, tau)
    end
    return tau_values
end


function generate_spin_autocorrelation(lattice::Lattice, beta_values::Vector{Float64}; l::Int64 = 1, move::String = "single flip", max_lag::Int64 = 250, measurement_steps::Int64 = 15000, equilib_steps::Int64 = 1250)
    MC_step = lattice.L^2
    lag = 0:max_lag
    autocorr_beta = []

    for beta in beta_values
        println("beta = $beta")
        time = now()
        history = Vector{Matrix{Int64}}()

        #p = plot()
        #heatmap!(p,lattice.grid)
        #savefig(p, "$(beta)_init.png")

        #equilibriate for equilib_steps before measuring
        for _ in 1:equilib_steps * MC_step
            monte_carlo_timestep!(lattice, move, beta, l = l)
        end
        
        #p = plot()
        #heatmap!(p,lattice.grid)
        #savefig(p, "$(beta)_equilb.png")
        
        
        
        #measure lattice configuration every MC step
        for j in 1:measurement_steps
            push!(history, copy(lattice.grid))
            for _ in 1:MC_step
                monte_carlo_timestep!(lattice, move, beta, l = l)
            end
        end
        


        n_history = length(history)
        lattice_avg = zeros(size(history[1])...)
        for mat in history
            lattice_avg .+= mat
        end

        lattice_avg ./= n_history
        
        
        autocorr_history = []
        for tau in lag
            autocorr_matrix = zeros(lattice.L, lattice.L)
            for t0 in 1:(length(history) - tau)
                autocorr_matrix += (history[t0] .- lattice_avg) .* (history[t0 + tau] .- lattice_avg)
            end
            autocorr_matrix = autocorr_matrix ./ (length(history) - tau)
            push!(autocorr_history, autocorr_matrix)
        end
        autocorr_history = [autocorr_history[t] ./ autocorr_history[1] for t in eachindex(autocorr_history)]
        autocorr = [mean(mat) for mat in autocorr_history]
        push!(autocorr_beta, (beta, autocorr))

    end

    return autocorr_beta
end

function generate_spin_tau(lattice::Lattice, beta_values::Vector{Float64}, save_file::Bool = false; l::Int64 = 1, move::String = "single flip", filename::String = "autocorrelation.csv", max_lag::Int64 = 250, measurement_steps::Int64 = 15000, equilib_steps::Int64 = 1250)
    autocorr_beta = generate_spin_autocorrelation(lattice, beta_values, l = l, move = move, max_lag = max_lag, measurement_steps = measurement_steps, equilib_steps = equilib_steps)
    if save_file
        open(filename, "w") do io
            for entry in autocorr_beta
                autocorr = entry[2]  # Extract the autocorrelation vector
                writedlm(io, [autocorr], ',')  # Write as a row
            end
        end
    end

    tau_values = []
    for (i, beta) in enumerate(beta_values)
        autocorr = autocorr_beta[i][2]
        tau = length(autocorr)
        for (j,a) in enumerate(autocorr)
            if a < exp(-1)
                tau = j
                break
            end
        end
        push!(tau_values, tau)
    end
    return tau_values
end

function fit_stretched_exponential_from_autocorrelation_function(autocorr::Vector{Float64}; plot_fit::Bool = false, filename::String = "stretched_exponential_fit.png")
    function stretched_exponential(t, p)
        tau, alpha = p
        return exp.(-abs.(t ./ tau).^alpha)
    end

    x_data = Float64.(0:length(autocorr)-1)
    y_data = autocorr

    initial_params = [50, 0.5]
    lower_bounds = [1, 0.1]
    upper_bounds = [1e8, 1]

    fit = curve_fit(stretched_exponential, x_data, y_data, initial_params, lower=lower_bounds, upper=upper_bounds)
    fitted_params = fit.param
    tau = round(fitted_params[1], digits=2)
    alpha = round(fitted_params[2], digits=2)
    if plot_fit
        p = plot()
        plot!(p, x_data, y_data, label="Data", color=:blue)
        plot!(p, x_data, stretched_exponential(x_data, fitted_params), label="Fit", color=:red)
        xlabel!(p, "iterations")
        ylabel!(p, "Autocorrelation function")
        title!(p, "Stretched exponential fit: tau = $tau, alpha = $alpha")
        savefig(p, filename)
    end
    return fitted_params
end

function generate_stretched_fit(autocorr_beta::Vector{Vector{Float64}}, beta_values::Vector{Float64}; plot_fit::Bool = false, beta_indexes_to_plot::Vector{Int64} = [1], filename::String = "stretched_exponential_fit.png")
    fitted_params = Vector{Vector{Float64}}()
    for (i, autocorr) in enumerate(autocorr_beta)
        beta = beta_values[i]
        fit = fit_stretched_exponential_from_autocorrelation_function(autocorr)
        push!(fitted_params, fit)
    end

    function stretched_exponential(t, p)
        tau, alpha = p
        return exp.(-abs.(t ./ tau).^alpha)
    end

    if plot_fit
        p = plot()
        for i in beta_indexes_to_plot
            beta = beta_values[i]
            fit = fitted_params[i]
            x_data = Float64.(0:length(autocorr_beta[i])-1)
            plot!(p, x_data, autocorr_beta[i], label="beta = $beta", color=:blue)
            plot!(p, x_data, stretched_exponential(x_data, fit), label="beta = $beta", linestyle=:dash, color=:red)
        end
        xlabel!(p, "iterations")
        ylabel!(p, "Autocorrelation function")
        title!(p, "Stretched exponential fits")
        savefig(p, filename)
    end
    return fitted_params
end

function fit_VFT_from_stretched_exponential_fit(beta_values::Vector{Float64}, fitted_params::Vector{Vector{Float64}}; plot_fit::Bool = false, filename::String = "VFT_fit.png")
    function VFT(T, p)
        T_0, A, delta = p
        return A .* exp.(delta ./ (T .- T_0))
    end
    tau_values = [p[1] for p in fitted_params]
    T_values = 1 ./ beta_values

    initial_params = [1.0, 1.0, 1.0]
    lower_bounds = [0.0, 0.0, 0.0]
    upper_bounds = [Inf, Inf, Inf]
    println(tau_values)
    fit = curve_fit(VFT, T_values, tau_values, initial_params, lower=lower_bounds, upper=upper_bounds)
    fitted_params = fit.param
    p = plot()
    plot!(p, T_values, tau_values, label="Data", color=:blue)
    plot!(p, T_values, VFT(T_values, fitted_params), label="Fit", color=:red, linestyle=:dash)
    xlabel!(p, "Temperature")
    ylabel!(p, "tau")
    title!(p, "Vogel-Fulcher-Tammann fit")
    savefig(p, filename)
    return fitted_params
end
            
 

function prepare_lattice!(lattice::Lattice,l::Int64 = 1; MC_steps::Int64 = 10)
    #prepares lattice in minimal energy state (all aligned)
    #this is an accessible state if system is ergodic
    #then runs metropolis algorithm for beta = 0
    #for 100 Monte-Carlo steps - probably overkill?
    #equivalent to infinite temperature, all moves are accepted
    lattice.grid = solved_configuration(lattice.L)
    run_metropolis_algorithm(lattice, 0.0, l, maximum_iterations = MC_steps * lattice.L^2)
end


#used
function generate_energies(lattice::Lattice, beta_values::Vector{Float64}, l::Int64, tau_values::Vector{Int64}, move::String = "single flip", measurement_tau_separation::Int64 = 1)
    energies = Float64[]
    # beta values array of decreasing temperatures
    # as we cool from hot to cold
    # so increasing beta
    
    # for each beta value
    # run metropolis algorithm for n_correlation[i] iterations
    # our decorrelation cutoff determined by "generate_decorrelation_n"
    # calculate the total energy of the lattice and store in array

    #prepare lattice in hot state
    prepare_lattice!(lattice)
    MC_step = lattice.L^2
    for (i,beta) in enumerate(beta_values)
        #println("beta=$beta")
        run_metropolis_algorithm(lattice, beta, l, move, maximum_iterations = tau_values[i] * measurement_tau_separation*MC_step)
        E = energy(lattice)
        push!(energies, E)
    end
    return energies
end
    
function generate_saddles_run(lattice::Lattice, beta_values::Vector{Float64}, l::Int64, tau_values::Vector{Int64}, measurement_tau_separation::Int64 = 5, move::String = "single flip")

    # old function, very inefficient to anneal for each l individually
    # prepare lattice in a 'hot state'
    # for each beta
    # cool to beta using single spin flips
    # once cooled, explore moves, calculate energy of system

    prepare_lattice!(lattice)
    # we could also use the decorrelation_n here
    # to determine how many iterations it takes to cool?
    # make sure we're starting hot (low beta)
    saddle_values = Int64[]
    energy_values = Float64[]
    MC_step = lattice.L^2

    for (i,beta) in enumerate(beta_values)
        println("beta=$beta")
        run_metropolis_algorithm(lattice, beta, l, "single flip", maximum_iterations = tau_values[i]* measurement_tau_separation * MC_step)
        push!(energy_values, energy(lattice))
        saddles = explore_moves(lattice, l, move)
        push!(saddle_values,saddles)
    end
    return (saddle_values, energy_values, beta_values)
end
function generate_saddles_parallel(lattice::Lattice, beta_values::Vector{Float64}, l_values::Vector{Int64}, tau_values::Vector{Int64}, measurement_tau_separation::Int64 = 16, move::String = "single flip", copy_index::Int64 = 1)
    #improved function, set of l values measured for each annealing run

    saddle_values = zeros(Int64, (length(l_values), length(beta_values)))
    energy_values = zeros(Float64, (length(l_values), length(beta_values)))
    beta_values_matrix = zeros(Float64, (length(l_values), length(beta_values)))
    MC_step = lattice.L^2

    lattice.grid = random_configuration(lattice.L, 0.0)
    noisy_beta_values = beta_values .+ randn(length(beta_values)) .* 0.1 .* beta_values
    for (i,beta) in enumerate(noisy_beta_values)
        #println("beta=$beta")
        E_ref = onsager_energy(beta, lattice.L)
        E_diff = abs(energy(lattice) - E_ref)
        while E_diff > 0.05
            for _ in 1:(MC_step * 50)
                monte_carlo_timestep!(lattice, "single flip", beta, l = 1)
            end
            E = energy(lattice)
            E_diff = abs(E - E_ref)
        end
        for _ in 1:(MC_step * 50)
            monte_carlo_timestep!(lattice, "single flip", beta, l = 1)
        end

        for (j,l) in enumerate(l_values)
            energy_values[j,i] = energy(lattice)
            saddles = explore_moves(lattice, l, move)
            saddle_values[j,i] = saddles
            beta_values_matrix[j,i] = beta
        end
    end
    return (saddle_values, energy_values, beta_values_matrix)
end
